#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include "node.h"
#include "tree.h"
#include "y.tab.h"

/* constructors */
tree_t *make_tree(int type, int effective_type, tree_t *left, tree_t *right)
{
	tree_t *p = (tree_t *)malloc(sizeof(tree_t));
	assert(p != NULL);

	p->type = type;
	p->effective_type = effective_type;
	p->left = left;
	p->right = right;

	if ( left != NULL ){
		if ( left->effective_type != effective_type ){
			semError("Objects of different types appear in the same expression");
		}
	}

	if ( right != NULL ){
		if ( right->effective_type != effective_type ){
			semError("Objects of different types appear in the same expression");
		}
	}

	return p;
}

tree_t *make_op(int type, int attribute, tree_t *left, tree_t *right)
{
	tree_t *p;
	if ( right == NULL ){
		p = make_tree(type, left->effective_type, left, right);
	} else {
		p = make_tree(type, right->effective_type, left, right);
	}
	p->attribute.opval = attribute;
	return p;
}

tree_t *make_inum(int val)
{
	tree_t *p = make_tree(INUM, INUM, NULL, NULL);
	p->attribute.ival = val;
	return p;
}

tree_t *make_rnum(float val)
{
	tree_t *p = make_tree(RNUM, RNUM, NULL, NULL);
	p->attribute.rval = val;
	return p;
}

tr
{
	tree_t *p = make_tree(BOOL, BOOL, NULL, NULL);
	p->attribute.ival = val;
	return p;
}

tree_t *make_id(node_t *node)
{
	tree_t *p = make_tree(ID, node->effective_type, NULL, NULL);
	p->attribute.sval = node;
	return p;
}


/* preorder */
void print_tree(tree_t *t, int spaces)
{
	int i;

	if (t == NULL)
		return;

	for (i=0; i<spaces; i++) {
		fprintf(stderr, " ");
	}

	/* process root */
	switch(t->type) {
	case ID:
		fprintf(stderr, "[ID:%s]", (t->attribute.sval)->name);
		break;
	case INUM:
		fprintf(stderr, "[INUM:%d]", t->attribute.ival);
		break;
	case RNUM:
		fprintf(stderr, "[RNUM:%f]", t->attribute.rval);
		break;
	case BOOL:
		fprintf(stderr, "[BOOL:%f]", t->attribute.ival);
		break;
	case ADDOP:
		fprintf(stderr, "[ADDOP:%d]", t->attribute.opval);
		break;
	case MULOP:
		fprintf(stderr, "[MULOP:%d]", t->attribute.opval);
		break;
	case RELOP:
		fprintf(stderr, "[RELOP:%d]", t->attribute.opval);
		break;
	default:
		fprintf(stderr, "[UNKNOWN]");
		break;
	}
	fprintf(stderr, " || %d || ", t->effective_type);
	fprintf(stderr, "\n");

	/* go left */
	print_tree(t->left, spaces+4);
	/* go right */
	print_tree(t->right, spaces+4);

}

int semError(char *message)
{ 
  fprintf(stderr, "\n\nSemantic Error: %s\n", message);
  exit(1);
}


/*int same_types(tree_t *head, int type){
	if ( head->left == NULL ){
		if ( head->right == NULL ){
			return 1;
		} else {
			return ( head->type == (head->right)->type ) && ( same_types(head->right) );
		}
	} else if ( head->right == NULL ){
		if ( head->left == NULL ){ // Can probably remove this term
			return 1;
		} else {
			return ( head->type == (head->left)->type ) && ( same_types(head->left) );
		}
	} else {
		return	head->type == (head->left)->type &&
						head->type == (head->right)->type &&
						same_types(head->right) &&
						same_types(head->left);
	}
}
*/
